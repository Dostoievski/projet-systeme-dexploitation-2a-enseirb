#include <ucontext.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include "threadStructure.h"
#include "fifoThread.h"

/*
 * create an element from a thread
 */

element * createElement(thread *thr){
  element * elm = (element *)malloc(sizeof(element));
  if(elm){
    elm->th = thr;
    elm->next = NULL;
    elm->previous = NULL;
    return elm;
  }
  return NULL;  
}

/*
 *
 */

void killElement (element * elm){
  assert(elm);
  killThread(elm->th);
  free(elm);
}

/*
 *
 */

void killThreadByTid(fifoThread * fifo,thread_t tid){
  element *elm = getElementByTid(fifo,tid);
  elm->previous->next = elm->next;
  if(elm->next)
    elm->next->previous = elm->previous;
  killElement(elm);
}

/*
 * 
 */
thread* getThreadByTid (fifoThread* fifo, thread_t tid){
  element * elm = getElementByTid(fifo,tid); 
  if(elm)
    return elm->th;
  return NULL;
}

/* 
 * get the element in fifo that contains the thread 
 * corresponding to the tid
 */
struct element* getElementByTid(fifoThread*f ,thread_t tid){
  assert(f);
  element *tmp = f->head;
  while(tmp){
    if(tmp->th->tid == tid)
      return tmp;
    tmp = tmp->next;
  }  
  return NULL;
}

/*
 * create the fifo thread
*/

fifoThread * createFifoThread(){
  fifoThread* f = (fifoThread *)malloc(sizeof(fifoThread));
  if(f){
    f->head = NULL;
    f->tail = NULL;
    return f;
  }
  return NULL;
}

/*
 *
 */

int isEmptyFifo (fifoThread *fifo){
  assert(fifo);
  if(fifo->head)
    return 0;
  return 1;
}

/*
 * init a fifo thread
 */

void initFifoThread(fifoThread * fifo){
  assert(fifo);
  element *th = fifo->head;
  while(th){
    element * tmp = th;
    th = th->next;
    killElement(tmp);
  }
}

/*
 * kill a fifo thread
 */

void killFifoThread(fifoThread * fifo){
  initFifoThread(fifo);
  free(fifo);
}

/*
 * add an element to the fifo thread
 */

void enqueueFifoThread(fifoThread *fifo, thread *th){
  assert(fifo);
  
  element * elm = createElement(th);
  if(fifo->head){
    element * tmp = fifo->tail;
    fifo->tail->next = elm;
    fifo->tail = elm;
    fifo->tail->previous = tmp;
  }
  else{
    fifo->head = elm;
    fifo->tail = elm;
  }
}

/*
 * 
 */
int isTheHead (fifoThread* fifo, thread_t th){
  return (fifo && fifo->head &&(fifo->head->th->tid == th));
}

/*
 * return the thread which is at the head of fifo thread
 */

struct thread* getHeadFifoThread (fifoThread* fifo){
  assert(fifo->head);
  return fifo->head->th;
}

/*
 *
 */

void firstBecomesLast (fifoThread *fifo){
  if(hasMoreThanOneElement(fifo)){
    thread * th1 = getHeadFifoThread(fifo);
    killHeadFifoThread(fifo);
    enqueueFifoThread(fifo,th1);    
  }
}

/*
 * return the thread which is at the end of fifo thread
 */

struct thread* getTailFifoThread (fifoThread* fifo){
  return fifo->tail->th;
}

/*
 *
 */
int hasMoreThanOneElement(fifoThread* fifo){
  assert(fifo);
  if(fifo->head && fifo->head->next)
    return 1;
  return 0;
}

void killHeadFifoThread (fifoThread* fifo){
  assert(fifo->head);
  element * tmp = fifo->head;
  if(hasMoreThanOneElement(fifo)){
    fifo->head = fifo->head->next;
    fifo->head->previous = NULL;    
  }
  else{
    fifo->head = NULL;       
    fifo->tail = NULL;
  }    
  killElement(tmp);
}

/*
 *
 */
void killTailFifoThread (fifoThread* fifo){
  assert(fifo->tail);
  element * tmp = fifo->tail;
  if(hasMoreThanOneElement(fifo)){
    fifo->tail = fifo->tail->previous;
    fifo->tail->next = NULL;
  }
  else{
    fifo->head = NULL;       
    fifo->tail = NULL;
  }    
  killElement(tmp);
}

/*
 *
 */

void addInFifoHead(fifoThread * fifo, thread *th){
  assert(fifo);
  element * elm = createElement(th);
  if(fifo->head){
    element * tmp = fifo->head;
    fifo->head->previous = elm;
    fifo->head = elm;
    fifo->head->next = tmp;
  }
  else{
    fifo->head = elm;
    fifo->tail = elm;
  }
}
