#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"
#include "fifoThread.h"
#include "thread.h"

static int P_PRIORITY = 0;

static fifoThread fifo_READY ;//les threads non terminés
static fifoThread fifo_FINISH ;//les threads terminés

/*
 *Mets le thread dans la bonne pile
 */
void addInFifo(thread * th){
  if(!th)
    return;
  switch(th->state){
  case STATUS_READY:
    addFifoThread(&fifo_READY,th);
    break;
  case STATUS_FINISH:
    addFifoThread(&fifo_FINISH,th);
    break;
  default:
    perror("Statut invalide");
  }
}

/*
  Function: thread_self
  
  returns the tread ID
 */
thread_t thread_self(){
  return getRunningThreadTid();
}

/*
  Function:thread_create

  creates a new thread

  Parameters:
       t - the thread ID
       func-
       arg-

  Returns:
       an integer to report errors
 */
int thread_create(thread_t*t,void*(*func)(void *),void*arg){
  ucontext_t *uc = createContext((void (*) (void))func,arg);
  if(uc == NULL)
    return -1;
  *t = getNextTID();
  thread *th = newThread(*t, STATUS_READY, uc);
  addInFifo(getRunningThread());
  setRunningThread(th);
  swapcontext(uc->uc_link, uc);
  return 0;
}


/*
  Function:thread_yield

  forces the running thread to relinquish the thread
  until it again becomes the head of its thread list. 
  (Le processus sera alors déplacé à la fin de la liste des 
  threads prêts de sa priorité, et un autre thread 
  sera exécuté)
 
  Returns:
       an integer to report errors
 */

int thread_yield(){
  thread *th = getRunningThread();
  swapcontext(th->context,th->context->uc_link);
  return 0;
}

/*
  Function:thread_join

  suspends execution of the calling thread until
  the target thread terminates, unless the target 
  thread has already terminated  

  Parameters:
       thread - the thread ID
       retval - if!NULL the thread returned value
                will be stored in retval

  Returns:
       an integer to report errors
 */

thread* retrouverLeThread(thread_t tid){
  if(estLeThreadCourant(tid))
    return getRunningThread();

  //on le cherche dans la file d'attente
  thread* th = removeThreadByTid(&fifo_READY,tid);
  if(th == NULL){
    //on le cherche dans la file des threads termines
    th = removeThreadByTid(&fifo_FINISH,tid);
  }
  return th;//vaut NULL si pas trouve
}

thread* prochainThread(){
  //si aucun thread n'attend
  if(isEmptyFifo(&fifo_READY))
    return getRunningThread();
  //sinon on ordonnance
#if P_PRIORITY
  //ordonnancement: thread de plus grande priorité
  return removeBigPriority(&fifo_READY);
#else
  //ordonnancement: le premier de la liste d'attente
  return removeFifoHead(&fifo_READY);
#endif 
}

void nettoyage_thread_termine(thread* current){
  //on fait le lien entre la valeur de retour et son adresse
  //et on libere la memoire occupée par le thread
  if(current->adresseValRetour != NULL)
    *(current->adresseValRetour) = current->valRetour;
  free(current->context->uc_link);
  free(current->context->uc_stack.ss_sp);
  free(current->context);
  free(current);
  setRunningThread(NULL);
}

void attendreLeThread(thread* waitingFor){
  //Si le thread a terminé, on nettoie et on quitte
  if(waitingFor->state == STATUS_FINISH){
      nettoyage_thread_termine(waitingFor);
      return;
  }
  //sinon on lance un autre thread
  thread* th = prochainThread();
  if(!estLeThreadCourant(th->tid)){
    addInFifo(getRunningThread());
    setRunningThread(th);
  }
  swapcontext(th->context->uc_link, th->context);
  //et on continue d'attendre le thread pour qu'il termine
  attendreLeThread(waitingFor);
}

int thread_join(thread_t identity, void **retval){
  thread* th = retrouverLeThread(identity);
  if(!th)//si le thread est inexistant
    return -1;
  //on recupere l'adresse de la valeur de retour
  th->adresseValRetour = retval;

  //th devient le thread courant s'il ne l'est pas
  if(!estLeThreadCourant(th->tid)){
    addInFifo(getRunningThread());
    setRunningThread(th);
  }  

  //Si le thread a déjà terminé, on nettoie et on quitte
  if(th->state == STATUS_FINISH){
    nettoyage_thread_termine(th);
    return 0;
  }
  //sinon on lance le thread et on l'attend
  swapcontext(th->context->uc_link, th->context);
  attendreLeThread(th);
  return 0;
}

/*
  Function:thread_exit

  terminates the calling thread

  Parameters:
       retval - available to any successful join 
                with the terminating thread
  Returns:
       an integer to report errors
 */

void thread_exit(void *retval){
  thread *th = getRunningThread();
  //on recupere la valeur de retour
  th->valRetour = retval;
  th->state = STATUS_FINISH;
  setcontext(th->context->uc_link);
  exit(1);
}
