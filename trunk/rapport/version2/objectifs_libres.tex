\section{Objectifs libres}

\subsection{Pr√©emption}

Ici, nous allons nous int\'eresser \`a l'objectif libre concernant la pr\'eemption. Dans ce projet, pour simuler les interruptions qui imposent \`a l'ordonnanceur d'effectuer un changement de contexte, nous utilisons les signaux \textit{POSIX}. Dans notre impl\'ementation, la biblioth\`eque de threads masque les interruptions en bloquant la remise de ces signaux en utilisant des appels syst\`eme. M\^eme si nous avons impl\'ement\'e des threads pr\'eemptifs, ils peuvent masquer les interruptions et ne pas \^etre pr\'eempt\'e jusqu'a ce qu'ils appellent \textit{thread\_yield}().\\
Les fonctions relatives \`a la pr\'eemption sont d\'efinis dans les fichiers \textit{timer.c} et \textit{timer.h}. Nous avons un gestionnaire de signaux qui est install\'e et lanc\'e qu'une seule fois, lors du premier appel \`a la fonction \textit{thread\_create} plus pr\'ecisemment quand la fonction main du processus appelant est identifi\'e et convertit en thread (d'identifiant 0). Le signal responsable du changement de contexte et donc celui qui est envoy\'e \`a intervalle de temps r\'egulier est \textit{SIGALRM}. Lors de l'appel \`a la fonction scheduler, le gestionnaire est install\'e et ensuite un appel \`a la fonction ualarm (qui est un appel syst\`eme) provoque un appel \`a la fonction interruptHandler qui elle va provoquer le changement de contexte. A l'entr\'ee de la fonction, les interruptions sont masqu\'ees, elle fait ensuite un autre appel a ualarm et effectue un changement de contexte.
La pr\'eemption introduit de nouveaux probl\`eme de synchronisation. Effectivement, lors d'appel aux fonctions de la bibliotheque comme \textit{thread\_create}, \textit{thread\_yield} ou \textit{thread\_exit} par exemple, si la fonction est interrompue par un signal divers probl\`emes peuvent se produire. Ces fonctions utilisent des variables globales telles que les differentes files de threads, le thread courant, et bien d'autre. Tout cela peut aboutir \`a des donn\'ees incoh\'erentes d'ou la n\'ec\'essit\'e de masquer les interruptions lors de leur execution.

\subsection{Protection de la pile}

Concernant la protection de la pile des threads, nous avons utilis\'e la fonction mprotect. En fait, lors de la cr\'eation d'un nouveaux thread, nous lui allouons une pile correspondant \`a 4 pages m\'emoires et les droits associ\'es. Un gestionnaire de signaux a \'et\'e au pr\'ealablement install\'e pour capter les signaux \textit{SIGSEGV}. Le thread responsable de l'instruction qui a d\'eclench\'e ce signal est alors d\'etruit et le programme peut continuer son execution. A ce niveau, nous avons rencontr\'e certains probl\`emes. En effet, nous ne captons pas tous les signaux \textit{SIGSEGV}, et le programme peut alors s'arr\'eter brutalement.

\subsection{Politiques d'ordonnancement}

Afin de mieux avantager les threads ayant des fonctions plus importantes, nous avons mis en place un systeme de priorit\'e et d\'efinit diff\'erentes politiques d'ordonnancement. Un champs priorit\'e a \'et\'e introduit dans la structure thread et chaque fois qu'il execute l'une des fonctions suivantes \textit{thread\_yield}, \textit{thread\_create}, \textit{thread\_join} la priorit\'e du thread diminue progressivement.Plus le champs priorit\'e est \'elev\'e, plus le thread est important. Ainsi, il sera alors possible de d\'efinir \`a la compilation le type d'ordonnancement effectu\'e par la fonction \textit{thread\_yield}. Soit \`a la suite de l'appel de cette fonction le futur thread \`a s'\'ex\'ecuter sera le premier thread disponible, soit ce sera le thread de plus grande priorit\'e.

Pour mieux optimiser la recherche d'un thread en particulier ou d'autres actions, nous avons s\'epar\'e l'ensemble des threads en 3 files, une pour les threads pr\^ets, une pour les threads bloqu\'es (dans un join ou une semaphore par exemple) et une pour les threads termin\'es.

\subsection{Semaphore}

\subsection{Identification du \textsf{MAIN}}
Dans cette section il est question de definir un thread principal correspondant au \textsf{main du programme} et donc du pouvoir le manipuler comme n'importe quel autre thread.
