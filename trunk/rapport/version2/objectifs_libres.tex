\section{Objectifs libres}
Après les objectifs principaux qui consistaient à implémenter les plus importantes fonctions de la bibliothèque définies plus haut, nous parlerons à présent des objectifs libres que nous avons choisi de développer. 

\subsection{Préemption}

Dans ce projet, pour simuler les interruptions qui imposent \`a l'ordonnanceur d'effectuer un changement de contexte, nous utilisons les signaux \textit{POSIX}. Dans notre impl\'ementation, nous masquons les interruptions en bloquant la remise de ces signaux par des appels syst\`eme afin d'éviter des changements de contexte pendant certains moments critiques du programme comme la création d'un thread.\footnote{Les fonctions relatives \`a la pr\'eemption sont d\'efinis dans les fichiers \textit{timer.c} et \textit{timer.h}}. Nous avons un gestionnaire de signaux qui est install\'e et lanc\'e qu'une seule fois, lors du premier appel \`a la fonction \textit{thread\_create} plus pr\'ecisemment quand la fonction main du processus appelant est identifi\'e et convertit en thread. Le signal responsable du changement de contexte et donc celui qui est envoy\'e \`a intervalle de temps r\'egulier est \textit{SIGALRM}. Lors de l'appel \`a la fonction scheduler, le gestionnaire est install\'e et ensuite un appel \`a la fonction ualarm (qui est un appel syst\`eme) provoque un appel \`a la fonction interruptHandler qui elle va provoquer le changement de contexte. A l'entrée de la fonction, les interruptions sont masqu\'ees, elle fait ensuite un autre appel a ualarm et effectue un changement de contexte.
La pr\'eemption introduit de nouveaux probl\`eme de synchronisation. Effectivement, lors d'appel aux fonctions de la bibliotheque comme \textit{thread\_create}, \textit{thread\_yield} ou \textit{thread\_exit} par exemple, si la fonction est interrompue par un signal divers probl\`emes peuvent se produire. Ces fonctions utilisent des variables globales telles que les differentes files de threads, le thread courant, et bien d'autre. Tout cela peut aboutir \`a des donn\'ees incoh\'erentes d'ou la n\'ec\'essit\'e de masquer les interruptions lors de leur execution.

\subsection{Protection de la pile}

Concernant la protection de la pile des threads, nous avons utilis\'e la fonction \textit{mprotect}. En fait, lors de la cr\'eation d'un nouveau thread, nous lui allouons une pile correspondant \`a 4 pages m\'emoires et les droits associ\'es. Un gestionnaire de signaux a \'et\'e au pr\'ealablement install\'e pour capter les signaux \textit{SIGSEGV}. Le thread responsable de l'instruction qui a d\'eclench\'e ce signal est alors d\'etruit et le programme peut continuer son execution. A ce niveau, nous avons rencontr\'e certains probl\`emes. En effet, nous ne captons pas tous les signaux \textit{SIGSEGV}, et le programme peut alors s'arr\'eter brutalement.

\subsection{Politiques d'ordonnancement}

Afin de mieux avantager les threads ayant des fonctions plus importantes, nous avons mis en place un systeme de priorit\'e et d\'efinit diff\'erentes politiques d'ordonnancement. Un champs priorit\'e a \'et\'e introduit dans la structure thread et chaque fois qu'il execute l'une des fonctions suivantes \textit{thread\_yield}, \textit{thread\_create}, \textit{thread\_join} la priorit\'e du thread diminue progressivement. Plus le champs priorit\'e est \'elev\'e, plus le thread est important. Ainsi, il sera alors possible de définir \`a la compilation le type d'ordonnancement effectu\'e par la fonction \textit{thread\_yield}. Soit \`a la suite de l'appel de cette fonction le futur thread \`a s'\'ex\'ecuter sera le premier thread disponible, soit ce sera le thread de plus grande priorit\'e.

Pour mieux optimiser la recherche d'un thread en particulier ou d'autres actions, nous avons s\'epar\'e l'ensemble des threads en 3 files, une pour les threads pr\^ets, une pour les threads bloqu\'es (dans un join ou une semaphore par exemple) et une pour les threads termin\'es.

\subsection{Fonctions de synchronisation: les sémaphores}

Un sémaphore est représenté par une structure\footnote{Pour plus d'informations se référer au fichier \texttt{my\_semaphore\{.h,.c\}}} contenant un champ permettant d'identifier de façon unique le sémaphore et d'un deuxième champ correspondant à la valeur initiale du sémaphore. Un thread ne peut activé qu'un seul sémaphore à la fois et ne peut désactiver que le seul sémaphore qu'il a éventuellement activé. L'information <<le thread a activé un sémaphore>> et l'identité du sémaphore activé sont stockés dans la structure du thread. Pour tester l'implémentation des sémaphores nous avons deux programmes identiques à la seule différence que l'un utilise des sémaphores et l'autre non, correspondant respectivement aux fichiers \textsf{test-savec-semaphore.c} et \textsf{test-sans-semaphore.c}. Ce programme met en place deux threads, l'un affiche la lettre \texttt{A} dans une boucle sur la sortie standard et l'autre affiche la lettre \text{B} également dans une boucle sur la sortie standard. Avec le programme qui utilise les sémaphores, à la sortie on a des \text{A} puis des \textsf{B} alors qu'avec le deuxième programme on a plutôt un mélange de ces deux lettres qui n'est pas forcement le même à chaque exécution.     

\subsection{Identification du \textsf{MAIN}}
Dans cette section il est question de definir un thread principal correspondant au \textsf{main du programme} et donc de pouvoir le manipuler comme n'importe quel autre thread. Pour ce faire, on définit un thread ayant pour contexte le programme principal. L'identifiant du thread principal est alors stocké dans une variable globale afin de pouvoir accéder au thread pour des traitements particuliers sinon le thread en question est manipuler comme les autres. Cependant un problème survient quant à la libération des ressources de ce thread principal dans la mesure où les ressources liées à un thread ne sont libérées que dans la fonction \texttt{thread\_join}  généralement appelé par un thread père pour récupérer la valeur de retour d'un de ces thread fils. 
