\subsection{Les perfomances :}
\subsubsection{Coût de création et d'attente :}
Pour comparer le coût de la création avec thread et pthread, le fichier \textbf{creationAttente.c} a été mis en place.\\
On y crée un thread et un pthread. On a aussi deux fonctions \textit{pthreadfunc} et \textit{threadfunc} qui utilisent respectivement les fonctions des bibliothèques \textit{pthread} et \textit{thread}.\\
Nous remarquons alors que le coût de la création et d'attente avec les fonctions de la bibliothèque \textit{thread} est moindre par rapport aux autres. Nous pouvons expliquer ceci par le fait qu'avec un fonctionnement préemptif (utilisant la bibliothèque \textit{pthread}), le coût des appels système (les threads communiquent directement avec le kernel) s'additionne, contrairement aux fonctions avec la bibliothèque \textit{thread} qui elles, utilisent un ordonnancement coopératif.\\
Il est possible de compiler ce fichier à l'aide de la commande \textit{make creationAttente}.
\subsubsection{Coût du changement de contexte :}
Pour comparer le coût du changement de contexte avec thread et pthread, le fichier \textbf{chgContext.c} a été mis en place.\\
On y crée deux threads et trois pthreads. On a aussi deux fonctions \textit{pthreadfunc} et \textit{threadfunc} qui utilisent respectivement les fonctions des bibliothèques \textit{pthread} et \textit{thread} comme ce qui a été vu précédemment.\\
Nous remarquons alors que le coût dub changement de contexte avec les fonctions de la bibliothèque \textit{pthread} est moindre par rapport aux autres.\\
Il est possible de compiler ce fichier à l'aide de la commande \textit{make chgContexte}.
\subsubsection{Coût de la destuction :}
Pour comparer le coût de la destruction avec thread et pthread, le fichier \textbf{destruction.c} a été mis en place.\\
C'est un fichier semblable au programme exemple qui nous a été fourni, sauf que nous utilisons deux fonctions :  \textit{pthreadfunc} et \textit{threadfunc} qui utilisent respectivement les fonctions des bibliothèques \textit{pthread} et \textit{thread}.\\
Nous remarquons alors que le coût de la destruction avec les fonctions de la bibliothèque \textit{thread} est de loin inférieur à celui avec les autres fonctions.\\
Aussi, nous avons expliciter le fait qu'il soit possible, grâce à la nouvelle implémentation, de créer des threads qui font un \textit{thread\_join} avant le \textit{thread\_exit}, et vis versa. Pour ce, le fichier \textbf{freedMemory.c} a été créé.
Il est possible de compiler ces fichiers à l'aide de la commande \textit{make freedMemory} et \textit{make destuction}.

\subsection{Les applications :}
\subsubsection{ Somme de tous les éléments d'un grand tableau par diviser-pour-régner :}
Cette application se trouve dans le fichier \textbf{somme.c}.\\
Le principe est de diviser le tableau pour en calculer la somme plus rapidement. Notre tableau est de taille 1000, on le divise en dix tableaux de taille 100 en lançant un thread sur chacun des tableaux. Les threads calculent la somme de la partie du tableau qui les concerne, puis on retourne la somme totale.\\
Ceci est effectué avec les fonctions de la bibliothèque \textit{pthread} et les fonctions implémentées de la bibliothèque \textit{thread}, chose qui nous permet de comparer le coût du calcul de la somme des deux différentes manières.\\
On remarque alors que le fait d'ulitiser la bibliothèque \textit{thread} est plus rapide puisque l'on peut en parallel calculer les différentes parties du tableau. Concernant la bibliothèque \textit{pthread}, on peut justifier le fait qu'il soit plus lent relativement à l'autre bibliothèque par le fait qu'il ait besoin d'un appel système, c'est-à-dire qu'il va jusqu'au noyau pour faire toutes les opérations.\\
\subsubsection{ Calcul de la suite de Fibonacci :}
Cette application se trouve dans le fichier \textbf{fibo.c}.\\
Pour le calcul du terme $n$ de la suite, un thread principal est lancé. Sachant que pour ce faire ,on a bésoin des deux termes précedents (terme $n-1$ et terme $n-2$), le thread principal lance deux autres sur les calculs de ces termes et attend qu'il terminent pour pouvoir utilisé leur valeur de retour et tous les threads se comportent comme un thread principal.
Avant de lancer un thread sur le calcul d'un terme, le thread principal effectue un test au préalable pour verifier si la valeur du terme en question n'est déjà pas disponible afin d'éviter qu'un thread refasse un calcul déjà effectué par un autre et optise-t-on ainsi le nombre de threads utilisés dans le calcul des termes de la suite de fibonacci.  

\subsubsection{ Tri d'un grand tableau :}
Cette application se trouve dans le fichier \textbf{tri.c}.\\
Sans faire de fusion, nous nous sommes juste limité à trier le tableau portion par portion. La tableau est divisé en des portions de $20$ éléments chacune et un thread est lancé sur une portion pour l'ordonner de façon croissante. Après chaque itération un appel \texttt{thread\_yield} est effectué pour attester le changement de context sans faille de notre bibliothèque.
