#include <ucontext.h>
#include <stdlib.h>
#include <stdio.h>

//#include "threads.h"

typedef struct thread {
  int tid;
  struct thread * next;
  ucontext_t state;
} thread_t;

#define thread_null (thread_t *)0

struct thread_queue {
  thread_t * head;
  thread_t * tail;
};

static int tid_count;                  /* thread counter */
static struct thread_queue readylist;  /* the list of all ready threads */
static struct thread_queue joinlist;
static struct thread * current = thread_null;        /* the current running thread */

/****                              *
 * code for thread_queue data type *
 *                              ****/

static void thread_queue_init( struct thread_queue * q )
/* initialize q */
{
  q->head = thread_null;
  q->tail = thread_null;
}


static void thread_enqueue( thread_t * t, struct thread_queue * q )
/* enqueue t on q */
{
  t->next = thread_null;
  if (q->head == thread_null) {
    q->head = t;
    q->tail = t;
  } else {
    q->tail->next = t;
    q->tail = t;
  }
}

static thread_t * thread_dequeue( struct thread_queue * q )
/* dequeue and return a thread from q */
{
  if (q->head == thread_null) {
    return thread_null;
  } else {
    thread_t * t;
    t = q->head;
    q->head = t->next;
    return t;
  }
}

static thread_t * thread_dequeue_spe( struct thread_queue * q, thread_t *thread )
/* dequeue and return a special thread from q */
{
  if (q->head == thread_null) {
    return thread_null;
  } else {
    thread_t * t;
    int i;
    for (i=0; i<tid_count; i++) {
      if ((t = q->head) == thread)
 q->head = t->next;
      else {
 t = thread_dequeue(q);
 thread_enqueue(t,q);
      }
    }
    return t;
  }
}


int thread_self(void) {
  return current->tid;
}

int thread_create(thread_t *newthread, void * (*func)(void *), void *funcarg) {
  if ((newthread = malloc(sizeof(thread_t))) == NULL) {
    perror("Not enough memory for another thread!!!");
    exit(1);
  }
  newthread->tid = ++tid_count;
  getcontext(&(newthread->state));
  (newthread->state).uc_stack.ss_size = 16 * 1024;

  if (((newthread->state).uc_stack.ss_sp = malloc((newthread->state).uc_stack.ss_size)) == NULL)
    perror("malloc"), exit(1);

  (newthread->state).uc_stack.ss_flags = 0;
  (newthread->state).uc_link = NULL;
  makecontext(&(newthread->state), func, 1, (int *) funcarg);
 
  thread_enqueue(newthread, &readylist );

  return 0;
}

int thread_yield(void) {
  ucontext_t previous;
  thread_t * is_running;
 
  is_running = current;

  current = thread_dequeue( &readylist );
  if (current == thread_null) {
    /* crisis */
    fprintf(stderr, "No threads!\n");
    exit(-1);
  }
  else {
    if (is_running == thread_null)
      swapcontext(&previous,&(current->state));
    else { thread_enqueue(is_running, &readylist);
      current->state.uc_link = &(is_running->state);
      swapcontext(&(is_running->state),&(current->state));
     
    }
   
  }
  return current->tid;
}

int thread_join(thread_t * thread, void **retval) {
  thread_enqueue(thread_dequeue_spe(&readylist, thread),&joinlist );
}
