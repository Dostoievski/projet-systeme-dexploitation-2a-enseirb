#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"
#include "fifoThread.h"
#include "thread.h"

fifoThread * fifo = NULL;

thread_t thread_self(void){
  return getTidThread(getHeadFifoThread(fifo));
}

int thread_create(thread_t*t,void*(*func)(void *),void*arg){
  thread * th;
  ucontext_t *uc = createContext((void (*) (void))func,arg);
  if(!uc)
    return -1;
  *t = getNextTID();
  th = newThread(*t, uc);
  if(!fifo)
    fifo = createFifoThread();
  enqueueFifoThread(fifo, th);
  becomeFirst(fifo, *t);
  swapcontext(uc->uc_link, uc);
  return 0;
}


int thread_yield(void){
  if(isEmptyFifo(fifo))
    return -1;
  if(hasMoreThanOneElement(fifo)){
    thread * th1 = getHeadFifoThread(fifo);
    ucontext_t * uc1 = getThreadContext(th1);
    firstBecomesLast(fifo);
    thread * th2 = getHeadFifoThread(fifo);
    ucontext_t * uc2 = getThreadContext(th2);
    swapcontext(uc1, uc2);
  }
  return 0;
}

int thread_join(thread_t thread, void **retval){
  /*struct thread * th = getThreadByTid(fifo,thread);
  if(!th)
    return -1;
  if(!isTheHead(fifo, thread)){
    addInFifoHead(fifo,th);
  }
  ucontext_t * uc = getThreadContext(th);
  swapcontext(uc->uc_link, uc);
  //if(retval==NULL) stocker la fonction!!!!
  return 0;
  //else */
}

int thread_exit(void *retval){
  static int i = 0;
  printf("appel %d\n",++i);
  return i;
}
