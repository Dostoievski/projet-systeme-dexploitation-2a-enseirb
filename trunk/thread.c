#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"
#include "fifoThread.h"
#include "thread.h"

fifoThread * fifo = NULL;

thread_t thread_self(void){
  return getTidThread(getHeadFifoThread(fifo));
}

ucontext_t* createContext(void(*func)(void),void *funcarg){
  ucontext_t *uc;
  getcontext(uc);
  uc->uc_stack.ss_size = 64*1024;
  uc->uc_stack.ss_sp = malloc(uc->uc_stack.ss_size);
  if(!uc->uc_stack.ss_sp)
    return NULL;
  uc->uc_link = NULL;
  makecontext(uc,func, 1, funcarg);
  return uc;
}

int thread_create(thread_t *newthread, void (*func)(void ), void *funcarg){
  thread * th;
  ucontext_t *uc = createContext(func,funcarg);
  if(!uc)
    return -1;
  *newthread = getNextTID();
  th = newThread(*newthread, uc);
  if(!fifo)
    fifo = createFifoThread();
  enqueueFifoThread(fifo, th);
  return 0;
}


int thread_yield(void){
  thread * th1 = getHeadFifoThread(fifo);
  killHeadFifoThread(fifo);
  enqueueFifoThread(fifo,th1);
  thread * th2 = getHeadFifoThread(fifo);
  ucontext_t * uc1 = getThreadState(th1);
  ucontext_t * uc2 = getThreadState(th2);
  uc2->uc_link = uc1;
  swapcontext(uc1,uc2);
  return 0;
}

int thread_join(thread_t thread, void **retval){
  struct thread * th = getThreadByTid(fifo,thread);
  killThreadFromFifo(fifo,thread);
  addInFifoHead(fifo,th);
  ucontext_t * uc1 = getThreadState(th);
  ucontext_t * uc2 ;
  getcontext(uc2);
  uc1->uc_link = uc2;
  swapcontext(uc2,uc1);
  //  if(retval==NULL)
  return 0;
  //else
}

void thread_exit(void *retval){

}
