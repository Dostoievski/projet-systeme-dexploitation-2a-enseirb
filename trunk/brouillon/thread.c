#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"
#include "fifoThread.h"
#include "thread.h"

static int P_PRIORITY = 0;

static fifoThread fifo_READY ;//les threads non terminés
static fifoThread fifo_FINISH ;//les threads terminés
static fifoThread fifo_STOP ;//les threads qui attendent
                             //qu'un autre thread termine

/*
 *Mets le thread dans la bonne pile
 */
void addInFifo(thread * th){
  if(!th)
    return;
  switch(th->state){
  case STATUS_READY:
    addFifoThread(&fifo_READY,th);
    break;
  case STATUS_FINISH:
    addFifoThread(&fifo_FINISH,th);
    break;
  case STATUS_STOP:
    addFifoThread(&fifo_STOP,th);
    break;
  default:
    perror("Statut invalide");
  }
}

/*
  Function: thread_self
  
  returns the tread ID
 */
thread_t thread_self(){
  return getRunningThreadTid();
}

/*
  Function:thread_create

  creates a new thread

  Parameters:
       t - the thread ID
       func-
       arg-

  Returns:
       an integer to report errors
 */
int thread_create(thread_t*t,void*(*func)(void *),void*arg){
  ucontext_t *uc = createContext((void (*) (void))func,arg);
  if(uc == NULL)
    return -1;
  *t = getNextTID();
  thread *th = newThread(*t, STATUS_READY, uc);
  addInFifo(getRunningThread());
  setRunningThread(th);
  swapcontext(uc->uc_link, uc);
  return 0;
}


/*
  Function:thread_yield

  forces the running thread to relinquish the thread
  until it again becomes the head of its thread list. 
  (Le processus sera alors déplacé à la fin de la liste des 
  threads prêts de sa priorité, et un autre thread 
  sera exécuté)
 
  Returns:
       an integer to report errors
 */

int thread_yield(){
  thread *th1 = getRunningThread();
  thread *th2 = prochainThread();
  if(th1->priorite) 
    th1->priorite--;
  if(!estLeThreadCourant(th2->tid)){
    setRunningThread(th2);
    swapcontext(th1->context,th2->context);
  }
  return 0;
}

/*
  Function:thread_join

  suspends execution of the calling thread until
  the target thread terminates, unless the target 
  thread has already terminated  

  Parameters:
       thread - the thread ID
       retval - if!NULL the thread returned value
                will be stored in retval

  Returns:
       an integer to report errors
 */

thread* retrouverLeThread(thread_t tid){
  if(estLeThreadCourant(tid))
    return getRunningThread();

  //on le cherche dans la file d'attente
  thread* th = removeThreadByTid(&fifo_READY,tid);
  if(th == NULL){
    //on le cherche dans la file des threads termines
    th = removeThreadByTid(&fifo_FINISH,tid);
  }
  return th;//vaut NULL si pas trouve
}

thread* prochainThread(){
  //si aucun thread n'attend
  if(isEmptyFifo(&fifo_READY))
    return getRunningThread();
  //sinon on ordonnance
#if P_PRIORITY
  //ordonnancement: thread de plus grande priorité
  return removeBigPriority(&fifo_READY);
#else
  //ordonnancement: le premier de la liste d'attente
  return removeFifoHead(&fifo_READY);
#endif 
}

void nettoyage_thread_termine(thread* current){
  //on fait le lien entre la valeur de retour et son adresse
  //et on libere la memoire occupée par le thread
  if(current->adresseValRetour != NULL)
    *(current->adresseValRetour) = current->valRetour;
  free(current->context->uc_link);
  free(current->context->uc_stack.ss_sp);
  free(current->context);
  free(current);
  setRunningThread(NULL);
}

void attendreLeThread(thread* waitingFor){
  //Si le thread a terminé, on nettoie et on quitte
  if(waitingFor->state == STATUS_FINISH){
      nettoyage_thread_termine(waitingFor);
      return;
  }
  //sinon on lance un autre thread
  thread* th = prochainThread();
  if(!estLeThreadCourant(th->tid)){
    addInFifo(getRunningThread());
    setRunningThread(th);
  }
  swapcontext(th->context->uc_link, th->context);
  //et on continue d'attendre le thread pour qu'il termine
  attendreLeThread(waitingFor);
}

int thread_join(thread_t identity, void **retval){
  //thread attendu
  thread* waitingFor = retrouverLeThread(identity);
  //thread attendant
  thread* makingJoin = getRunningThread();
  
  //si le thread à attendre n'existe pas ou s'il attend un
  //autre thread 
  if(!waitingFor){
    return -1;
  }
  
  //on recupere l'adresse de la valeur de retour
  waitingFor->adresseValRetour = retval;
  
  //on stocke dans la structure le thread qui attend
  waitingFor->threadAttendant = makingJoin;
  
  //Si le thread a déjà terminé, on nettoie et on quitte
  if(th->state == STATUS_FINISH){
    nettoyage_thread_termine(waitingFor);
    return 0;
  }
  //sinon on lance le thread et on l'attend
  swapcontext(making_join->context, waitingFor->context);
  //attendreLeThread(th);
  return 0;
}

/*
  Function:thread_exit

  terminates the calling thread

  Parameters:
       retval - available to any successful join 
                with the terminating thread
  Returns:
       an integer to report errors
 */

void thread_exit(void *retval){
  thread *th = getRunningThread();
  //on recupere la valeur de retour
  th->valRetour = retval;
  //on met le statut a FINISH
  th->state = STATUS_FINISH;
  //s'il etait attendu par un autre thread
  if(th->threadAttendant){
    removeThreadByTid(&fifo_STOP,th->threadAttendant->tid);
    th->threadAttendant->state = STATUS_READY;
    addInFifo(th->threadAttendant);
    setRunningThread(th->threadAttendant);
    setcontext(th->threadAttendant->context);
  }
  else{
    th = prochainThread();
    if(!estLeThreadCourant(th->tid)){
      setRunningThread(th);
      setcontext(th->context);
    }
  }
  exit(1);
}
