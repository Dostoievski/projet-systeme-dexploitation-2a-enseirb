#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"

static thread* running_thread = NULL;

void setRunningThread(thread* th){
  running_thread = th;
}

int getRunningThreadTid(){
  if(running_thread == NULL)
    return 0;
  return running_thread->tid;
}

thread* getRunningThread(){
  return running_thread;
}

int estLeThreadCourant(int tid){
  return ((tid > 0) && (tid == getRunningThreadTid())); 
}

ucontext_t* createContext(void(*func)(void),void *funcarg){
  ucontext_t * uc = (ucontext_t*)malloc(sizeof(ucontext_t));
  getcontext(uc);
  uc->uc_link = (ucontext_t*)malloc(sizeof(ucontext_t));
  uc->uc_stack.ss_size = 64*1024;
  uc->uc_stack.ss_sp = malloc(uc->uc_stack.ss_size);
  if(!uc->uc_stack.ss_sp)
    return NULL;
  makecontext(uc,func, 1, funcarg);
  return uc;
}

thread * newThread(int tid, status state, ucontext_t* uc){
  thread * t = (thread *)malloc(sizeof(thread)); 
  if(t){
    t->tid = tid;
    t->context = uc;
    t->state = state;
    t->priorite = 0;
    return t;
  }
  return NULL;
}
 
/*
 * generation du TID unique d'un thread
 */
int getNextTID(){
  static int TID = 0;
  return ++TID;
}

/*
 *
 */
void * getValRetour(thread* th){
  return th->valRetour;
};

/*
 *
 */
enum status getStatus(thread* th){
  return th->state;
}
