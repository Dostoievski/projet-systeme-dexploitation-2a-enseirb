\subsection{Les perfomances}
\subsubsection{Coût de création et d'attente :}
Pour comparer le coût de la création avec thread et pthread, le fichier \texttt{creationAttente.c} a été mis en place.\\
On y crée un thread et un pthread. On a aussi deux fonctions \texttt{pthreadfunc} et \texttt{threadfunc} qui utilisent respectivement les fonctions des bibliothèques \textit{pthread} et \textit{thread}. Nous remarquons alors que le coût de la création et d'attente avec les fonctions de la bibliothèque \textit{pthread} est plus grand que celui obtenu avec les fonctions de notre bibliothèque et l'écart va de $0.33ms$ à plus de $1ms$. Nous pouvons expliquer ceci par le fait qu'avec un fonctionnement préemptif (utilisant la bibliothèque \textit{pthread}), le coût des appels système (les threads communiquent directement avec le kernel) s'additionne. Il est possible de compiler ce fichier à l'aide de la commande \texttt{make creationAttente}.

\subsubsection{Coût du changement de contexte }
Pour comparer le coût du changement de contexte entre thread et pthread, le fichier \texttt{chgContext.c} a été mis en place. On y crée deux threads et trois pthreads. On a aussi deux fonctions \texttt{pthreadfunc} et \texttt{threadfunc} qui utilisent respectivement les fonctions des bibliothèques \textit{pthread} et \textit{thread} comme ce qui a été vu précédemment. Nous remarquons alors que le coût du changement de contexte avec les fonctions de la bibliothèque \textit{pthread} est plus petit que celui obtenu avec les fonctions de notre bibliothèque avec un écart aux alentours de $0.02ms$. Il est possible de compiler ce fichier à l'aide de la commande \texttt{make chgContexte}.
\subsubsection{Coût de la destuction :}
Pour comparer le coût de la destruction avec thread et pthread, le fichier \texttt{destruction.c} a été mis en place.\\
C'est un fichier semblable au programme exemple qui nous a été fourni, sauf que nous utilisons deux fonctions :  \texttt{pthreadfunc} et \texttt{threadfunc} qui utilisent respectivement les fonctions des bibliothèques \textit{pthread} et \textit{thread}. Nous remarquons alors que le coût de la destruction avec les fonctions de la bibliothèque \textit{thread} est $100$ fois inférieur à celui obtenu avec les fonctions de la bibliothèque \textit{pthread}. Aussi, nous avons expliciter le fait qu'il soit possible, grâce à la nouvelle implémentation, de créer des threads qui font un \texttt{thread\_join} avant le \texttt{thread\_exit}, et vis versa. Pour ce, le fichier \texttt{freedMemory.c} a été créé. Il est possible de compiler ces fichiers à l'aide de la commande \texttt{make freedMemory} et \texttt{make destuction}.

\subsection{Les applications :}
\subsubsection{ Somme de tous les éléments d'un grand tableau par diviser-pour-régner :}
Cette application se trouve dans le fichier \texttt{somme.c}. Le principe est de diviser le tableau pour en calculer la somme plus rapidement. Notre tableau est de taille 1000, on le divise en dix tableaux de taille 100 en lançant un thread sur chacun des tableaux. Les threads calculent la somme de la partie du tableau qui les concerne, puis on retourne la somme totale.
Ceci est effectué avec les fonctions de la bibliothèque \textit{pthread} et les fonctions implémentées de la bibliothèque \textit{thread}, chose qui nous permet de comparer le coût du calcul de la somme des deux différentes manières. On remarque alors que le fait d'utiliser la bibliothèque \textit{thread} est très souvent rapide que d'utiliser la bibliothèque \textit{pthread}. La différence entre les coûts pouvant aller jusqu'à $2ms$ 
\subsubsection{ Calcul de la suite de Fibonacci :}
Cette application se trouve dans le fichier \textbf{fibo.c}. Pour le calcul du terme $n$ de la suite, un thread principal est lancé. Sachant que pour ce faire ,on a besoin des deux termes précédents (terme $n-1$ et terme $n-2$), le thread principal lance deux autres sur les calculs de ces termes et attend qu'il terminent pour pouvoir utiliser leur valeur de retour et tous les threads se comportent comme un thread principal. Le nombre de threads utilisés est fourni à la fin de l'exécution et pouvant excéder $100000$.

\subsubsection{ Tri d'un grand tableau :}
Cette application se trouve dans le fichier \textbf{tri.c}. Sans faire de fusion, nous nous sommes juste limités à trier le tableau portion par portion. Un tableau de taille 100 est divisé en des portions de 10 éléments chacune et un thread est lancé sur une portion pour l'ordonner de façon croissante. Après chaque itération un appel \texttt{thread\_yield} est effectué pour attester le changement de contexte sans faille de notre bibliothèque. Comme resultat, sur plusieurs exécutions on constate que notre bibliothèque est plus performante que la bibliothèque \texttt{lpthread} avec un écart avoisinant souvent $0.5ms$ 
