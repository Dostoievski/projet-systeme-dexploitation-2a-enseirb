#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"

static ucontext_t * current = NULL;
static thread_t threadCurrent;

void setCurrentThread(thread_t th){
  threadCurrent = th;
}

thread_t getCurrentThread(){
  return threadCurrent;
}

ucontext_t* mallocContext(){
  ucontext_t *uc = (ucontext_t*)malloc(sizeof(ucontext_t));
  return uc;
}

ucontext_t* createContext(void(*func)(void),void *funcarg){
  ucontext_t *uc = mallocContext();
  ucontext_t *uc2 = mallocContext();
  getcontext(uc);
  if(!current)
    current = mallocContext();
  getcontext(current);
  uc->uc_stack.ss_size = 64*1024;
  uc->uc_stack.ss_sp = malloc(uc->uc_stack.ss_size);
  if(!uc->uc_stack.ss_sp)
    return NULL;
  uc->uc_link = current;
  makecontext(uc,func, 1, funcarg);
  return uc;
}

thread * newThread(thread_t tid, status state, ucontext_t * uc){
  thread * t = (thread *)malloc(sizeof(thread)); 
  if(t){
    t->tid = tid;
    t->context = uc;
    t->state = state;
    t->code = func;
    t->arg = arg;
    return t;
  }
  return NULL;
}

thread_t getTidThread (thread* th){
  return th->tid;
}

ucontext_t* getThreadContext(thread* th){
  return th->context;
}

void killThread(thread * th){
  assert(th);
  if(th->context) 
    free(th->context);
  free(th);
}
  
/*
 * generation du TID unique d'un thread
 */
thread_t getNextTID(){
  static thread_t TID = 0;
  return ++TID;
}
