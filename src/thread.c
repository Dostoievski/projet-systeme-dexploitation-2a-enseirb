#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"
#include "fifoThread.h"
#include "thread.h"

static fifoThread * fifo_READY = NULL;
static fifoThread * fifo_FINISH = NULL;
static fifoThread * fifo_JOIN = NULL;

void addInFifo(thread * th){
  if(!th)
    return;
  switch(th->state){
  case STATUS_READY:
    if(fifo_READY == NULL)
      fifo_READY = createFifoThread();
    addFifoThread(fifo_READY,th);
    break;
  case STATUS_FINISH:
    if(fifo_FINISH == NULL)
      fifo_FINISH = createFifoThread();
    addFifoThread(fifo_FINISH,th);
    break;
  case STATUS_JOIN:
    if(fifo_JOIN == NULL)
      fifo_JOIN = createFifoThread();
    addFifoThread(fifo_JOIN, th);
    break;
  default:
    perror("Statut invalide");
  }
}

/*
  Function: thread_self
  
  returns the tread ID
 */
thread_t thread_self(){
  return getRunningThreadTid();
}

/*
  Function:thread_create

  creates a new thread

  Parameters:
       t - the thread ID
       func-
       arg-

  Returns:
       an integer to report errors
 */
int thread_create(thread_t*t,void*(*func)(void *),void*arg){
  ucontext_t *uc = createContext((void (*) (void))func,arg);
  if(uc == NULL)
    return -1;
  *t = getNextTID();
  thread *th = newThread(*t, STATUS_READY, uc);
  addInFifo(getRunningThread());
  setRunningThread(th);
  swapcontext(uc->uc_link, uc);
  return 0;
}


/*
  Function:thread_yield

  forces the running thread to relinquish the thread
  until it again becomes the head of its thread list. 
  (Le processus sera alors déplacé à la fin de la liste des 
  threads prêts de sa priorité, et un autre thread 
  sera exécuté)
 
  Returns:
       an integer to report errors
 */

int thread_yield(){
  thread *th = getRunningThread();
  ucontext_t *uc = th->context;
  swapcontext(uc,uc->uc_link);
  return 0;
}

/*
  Function:thread_join

  suspends execution of the calling thread until
  the target thread terminates, unless the target 
  thread has already terminated  

  Parameters:
       thread - the thread ID
       retval - if!NULL the thread returned value
                will be stored in retval

  Returns:
       an integer to report errors
 */

void thread_join_READY(thread * current){
  addInFifo(getRunningThread());
  setRunningThread(current);
  current->state = STATUS_JOIN;
  swapcontext(current->context->uc_link, current->context);
}

void thread_join_FINISH(thread* current){
  if(current->adresseValRetour != NULL)
    //on met l'adresse de retour dans l'adresse reservee
    *(current->adresseValRetour) = current->valRetour;
  free(current->context->uc_link);
  free(current->context);
  free(current);
}

void attendreLesThreads(){
  if(fifo_JOIN == NULL || isEmptyFifo(fifo_JOIN))
    return;
  //ici on enumerera plutard les poltiques d'ordonnancement
#if 1
  thread* th = removeFifoHead(fifo_JOIN);
  setRunningThread(th);
#endif 
  swapcontext(th->context->uc_link, th->context);
  if(th && th->state==STATUS_FINISH)//on teste si est fini
    thread_join_FINISH(th);
  else
    addInFifo(getRunningThread());
  attendreLesThreads();
}

int thread_join(thread_t tid, void **retval){
  thread* th = NULL;
  
  //On retrouve le thread et on le lance
  if(tid > 0 && tid == getRunningThreadTid()){//c'est le thread courant
    th = getRunningThread();
    //si on a deja fait un join du thread alors error!
    if(th->state == STATUS_JOIN)
      return -1;
    //on recupere l'adresse ou on doit stocker sa valeur 
    //de retour
    th->adresseValRetour = retval;
    //si le thread est termine
    if(th->state == STATUS_FINISH)
      thread_join_FINISH(th);
    else{
      th->state = STATUS_JOIN;//on change son statut
      ucontext_t *uc = th->context;
      //on le relance
      swapcontext(uc->uc_link, uc);
    }
  }
  else{
    //on le cherche parmis les threads dont on a pas encore
    //fait un join
    th = removeThreadByTid(fifo_READY,tid);
    if(th != NULL){
      //on recupere l'adresse ou on doit stocker sa valeur 
      //de retour
      th->adresseValRetour = retval;
      thread_join_READY(th);
    }
    else{ 
      //on le cherche parmis les threads qui ont termine
      th = removeThreadByTid(fifo_FINISH,tid);
      if(isEmptyFifo(fifo_FINISH))
	killFifoThread(fifo_FINISH);
      if(th != NULL){
	//on recupere l'adresse ou on doit stocker sa 
	//valeur de retour
	th->adresseValRetour = retval;
	thread_join_FINISH(th);
      }
      //thread inexistant ou un join de ce thread a deja 
      //ete fait donc error!
      else 
	return -1;
    }
  }
  
  //ici le thread a rendu la main 
  //et donc on revient dans la fonction join 
  //si le thread est fini on stocke sa valeur de retour
  th = getRunningThread();
  if(th && th->state==STATUS_FINISH)//on teste si est fini
    thread_join_FINISH(th);
  //on verifie si on a fait un join de tous les threads
  //crees et si c'est le cas on ne rend plus la main ai main
  //jusqu'a ce que tous les threads terminent
  if(fifo_READY == NULL || isEmptyFifo(fifo_READY)){
    if(fifo_READY)
      killFifoThread(fifo_READY);
    addInFifo(getRunningThread());
    attendreLesThreads();
    if(fifo_JOIN)
	killFifoThread(fifo_JOIN);
  }
  //on rend la main au main car on a pas encore fait un join
  //de tous les threads crees
  return 0;
}

/*
  Function:thread_exit

  terminates the calling thread

  Parameters:
       retval - available to any successful join 
                with the terminating thread
  Returns:
       an integer to report errors
 */

void thread_exit(void *retval){
  thread *th = getRunningThread();
  ucontext_t *uc = th->context;
  //on recupere la valeur de retour
  th->valRetour = retval;
  th->state = STATUS_FINISH;
  setcontext(uc->uc_link);
}
