#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"
#include "fifoThread.h"
#include "thread.h"

fifoThread * fifo = NULL;

/*
  Function: thread_self
  
  returns the tread ID
 */
thread_t thread_self(void){
  return getTidThread(getHeadFifoThread(fifo));
}

/*
  Function:thread_create

  creates a new thread

  Parameters:
       t - the thread ID
       func-
       arg-

  Returns:
       an integer to report errors
 */
int thread_create(thread_t*t,void*(*func)(void *),void*arg){
  thread * th;
  ucontext_t *uc = createContext((void (*) (void))func,arg);
  if(!uc)
    return -1;
  *t = getNextTID();
  th = newThread(*t, uc);
  if(!fifo)
    fifo = createFifoThread();
  enqueueFifoThread(fifo, th);
  //becomeFirst(fifo, *t);
  //swapcontext(uc->uc_link, uc);
  return 0;
}


/*
  Function:thread_yield

  forces the running thread to relinquish the thread
  until it again becomes the head of its thread list. 
  (Le processus sera alors déplacé à la fin de la liste des 
  threads prêts de sa priorité, et un autre thread 
  sera exécuté)
 
  Returns:
       an integer to report errors
 */

int thread_yield(void){
  if(isEmptyFifo(fifo))
    return -1;
  if(hasMoreThanOneElement(fifo)){
    thread * th1 = getHeadFifoThread(fifo);
    ucontext_t * uc1 = getThreadContext(th1);
    firstBecomesLast(fifo);
    thread * th2 = getHeadFifoThread(fifo);
    ucontext_t * uc2 = getThreadContext(th2);
    swapcontext(uc2->uc_link, uc2);
  }
  return 0;
}

/*
  Function:thread_join

  suspends execution of the calling thread until
  the target thread terminates, unless the target 
  thread has already terminated  

  Parameters:
       thread - the thread ID
       retval - if!NULL the thread returned value
                will be stored in retval

  Returns:
       an integer to report errors
 */

int thread_join(thread_t thread, void **retval){
  struct thread * th = getThreadByTid(fifo,thread);
  if(!th)
    return -1;
  if(!isTheHead(fifo, thread)){
    addInFifoHead(fifo,th);
  }
  ucontext_t * uc = getThreadContext(th);
  swapcontext(uc->uc_link, uc);
  //if(retval==NULL) stocker la fonction!!!!
  return 0;
  //else 
}

/*
  Function:thread_exit

  terminates the calling thread

  Parameters:
       retval - available to any successful join 
                with the terminating thread
      
  Returns:
       an integer to report errors
 */

int thread_exit(void *retval){
  static int i = 0;
  printf("appel %d\n",++i);
  return i;
}
