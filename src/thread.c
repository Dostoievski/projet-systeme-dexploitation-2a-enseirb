#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"
#include "fifoThread.h"
#include "thread.h"

static fifoThread fifo_READY ;//les threads non terminés
static fifoThread fifo_FINISH ;//les threads terminés

/*
 *Mets le thread dans la bonne pile
 */
void addInFifo(thread * th){
  if(!th)
    return;
  switch(th->state){
  case STATUS_READY:
    addFifoThread(&fifo_READY,th);
    break;
  case STATUS_FINISH:
    addFifoThread(&fifo_FINISH,th);
    break;
  default:
    perror("Statut invalide");
  }
}

/*
  Function: thread_self
  
  returns the tread ID
 */
thread_t thread_self(){
  return getRunningThreadTid();
}

/*
  Function:thread_create

  creates a new thread

  Parameters:
       t - the thread ID
       func-
       arg-

  Returns:
       an integer to report errors
 */
int thread_create(thread_t*t,void*(*func)(void *),void*arg){
  ucontext_t *uc = createContext((void (*) (void))func,arg);
  if(uc == NULL)
    return -1;
  *t = getNextTID();
  thread *th = newThread(*t, STATUS_READY, uc);
  addInFifo(getRunningThread());
  setRunningThread(th);
  swapcontext(uc->uc_link, uc);
  return 0;
}


/*
  Function:thread_yield

  forces the running thread to relinquish the thread
  until it again becomes the head of its thread list. 
  (Le processus sera alors déplacé à la fin de la liste des 
  threads prêts de sa priorité, et un autre thread 
  sera exécuté)
 
  Returns:
       an integer to report errors
 */

int thread_yield(){
  thread *th = getRunningThread();
  ucontext_t *uc = th->context;
  swapcontext(uc,uc->uc_link);
  return 0;
}

/*
  Function:thread_join

  suspends execution of the calling thread until
  the target thread terminates, unless the target 
  thread has already terminated  

  Parameters:
       thread - the thread ID
       retval - if!NULL the thread returned value
                will be stored in retval

  Returns:
       an integer to report errors
 */

void thread_nonTermine(thread * current){
  addInFifo(getRunningThread());
  setRunningThread(current);
  swapcontext(current->context->uc_link, current->context);
}

void thread_termine(thread* current){
  if(current->adresseValRetour != NULL)
    //on met la valeur de retour dans l'adresse reservee
    *(current->adresseValRetour) = current->valRetour;
  free(current->context->uc_link);
  free(current->context->uc_stack.ss_sp);
  free(current->context);
  free(current);
}

void attendreLeThread(thread_t tid){
  thread* th;
  if(isEmptyFifo(&fifo_READY)){
    th = getRunningThread();
    swapcontext(th->context->uc_link, th->context);
  }
  else{
#if 1
    //ici on enumerera plutard la politique d'ordonnancement
    th = removeFifoHead(&fifo_READY);
#endif 
    addInFifo(getRunningThread());
    setRunningThread(th);
    swapcontext(th->context->uc_link, th->context);
  }
  if(th->tid == tid){
    if(th->state==STATUS_FINISH){//on teste si est fini
      thread_termine(th);
      setRunningThread(NULL);
    }
    attendreLeThread(tid);
  }
  else{
    addInFifo(getRunningThread());
    attendreLeThread(tid);
  }
}

int thread_join(thread_t tid, void **retval){
  thread* th = NULL;
  
  //On retrouve le thread et on le lance
  if(tid > 0&&tid==getRunningThreadTid()){//c'est le courant
    th = getRunningThread();
    //on recupere l'adresse ou on doit stocker sa valeur 
    //de retour
    th->adresseValRetour = retval;
    //si le thread est termine
    if(th->state == STATUS_FINISH){
      thread_termine(th);
      setRunningThread(NULL);
    }
    else{
      ucontext_t *uc = th->context;
      //on le relance
      swapcontext(uc->uc_link, uc);
    }
  }
  else{
    //on le cherche parmis les threads dont on a pas encore
    //fait un join
    th = removeThreadByTid(&fifo_READY,tid);
    if(th != NULL){
      //on recupere l'adresse ou on doit stocker sa valeur 
      //de retour
      th->adresseValRetour = retval;
      thread_nonTermine(th);
    }
    else{ 
      //on le cherche parmis les threads qui ont termine
      th = removeThreadByTid(&fifo_FINISH,tid);
      if(isEmptyFifo(&fifo_FINISH))
	initFifoThread(&fifo_FINISH);
      if(th != NULL){
	//on recupere l'adresse ou on doit stocker sa 
	//valeur de retour
	th->adresseValRetour = retval;
	thread_termine(th);
	setRunningThread(NULL);
      }
      //thread inexistant ou un join de ce thread a deja 
      //ete fait donc error!
      else 
	return -1;
    }
  }
  
  //ici le thread a rendu la main 
  //et donc on revient dans la fonction join 
  //si le thread est fini on stocke sa valeur de retour
  th = getRunningThread();
  if(th){ 
    if(th->state==STATUS_FINISH){//on teste si est fini
      thread_termine(th);
      setRunningThread(NULL);
    }
    else{//le thread n'a pas encore termine, on l'attend
      attendreLeThread(th->tid);
    }
  }
  return 0;
}

/*
  Function:thread_exit

  terminates the calling thread

  Parameters:
       retval - available to any successful join 
                with the terminating thread
  Returns:
       an integer to report errors
 */

void thread_exit(void *retval){
  thread *th = getRunningThread();
  ucontext_t *uc = th->context;
  //on recupere la valeur de retour
  th->valRetour = retval;
  th->state = STATUS_FINISH;
  setcontext(uc->uc_link);
}
