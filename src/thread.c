#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <ucontext.h>
#include "threadStructure.h"
#include "fifoThread.h"
#include "thread.h"

static fifoThread * fifo = NULL;

static void** val_retour;

/*
  Function: thread_self
  
  returns the tread ID
 */
thread_t thread_self(void){
  return getCurrentThread();
}

/*
  Function:thread_create

  creates a new thread

  Parameters:
       t - the thread ID
       func-
       arg-

  Returns:
       an integer to report errors
 */
int thread_create(thread_t*t,void*(*func)(void *),void*arg){
  thread * th;
  ucontext_t *uc = createContext((void (*) (void))func,arg);
  if(!uc)
    return -1;
  *t = getNextTID();
  th = newThread(*t, STATUS_RUNNING, uc);
  if(!fifo)
    fifo = createFifoThread();
  enqueueFifoThread(fifo, th);
  setCurrentThread(*t);
  swapcontext(uc->uc_link, uc);
  return 0;
}


/*
  Function:thread_yield

  forces the running thread to relinquish the thread
  until it again becomes the head of its thread list. 
  (Le processus sera alors déplacé à la fin de la liste des 
  threads prêts de sa priorité, et un autre thread 
  sera exécuté)
 
  Returns:
       an integer to report errors
 */

int thread_yield(void){
  thread *th = getThreadByTid(fifo, getCurrentThread());
  ucontext_t *uc = getThreadContext(th);
  getcontext(uc);
  swapcontext(uc,uc->uc_link);
  return 0;
}

/*
  Function:thread_join

  suspends execution of the calling thread until
  the target thread terminates, unless the target 
  thread has already terminated  

  Parameters:
       thread - the thread ID
       retval - if!NULL the thread returned value
                will be stored in retval

  Returns:
       an integer to report errors
 */

int thread_join(thread_t thread, void **retval){
  struct thread * th = getThreadByTid(fifo,thread);
  
  if(!th)
    return -1;
  ucontext_t * uc = getThreadContext(th);
  setCurrentThread(thread);

  if((retval!=NULL) && (getStatus(th) == STATUS_FINISH)){
    printf(" ====rtyu %s\n",(char*)(th->valRetour));
    *retval = th->valRetour;
    return 0;
  }

  if(th->state != STATUS_FINISH){
  swapcontext(uc->uc_link, uc);
  return 0; 
  }
}

/*
  Function:thread_exit

  terminates the calling thread

  Parameters:
       retval - available to any successful join 
                with the terminating thread
      
  Returns:
       an integer to report errors
 */

void thread_exit(void *retval){
  /*faire le nettoyage dans le thread_join*/
  thread *th = getThreadByTid(fifo, getCurrentThread());
  printf(" ====tid %d\n",(th->tid));
  ucontext_t *uc = getThreadContext(th);
  th->valRetour = retval;
  th->state = STATUS_FINISH;
  printf(" ==== %s\n",(char*)(th->valRetour));
  getcontext(uc);
  setcontext(uc->uc_link);
}
